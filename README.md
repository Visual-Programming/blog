# blog

Здесь собрана информация для будущих разработчиков Node-red

Blogs

## Перемещение Node-RED в монорепо с несколькими модулями

| Как мы разорвали внутренние части Node-RED и склеили его вместе без ведома пользователей

Есть две логические части Node-RED; среда выполнения, в которой выполняются потоки, и редактор, в котором редактируются потоки. С самого начала проекта эти две части были объединены в один блок модуля npm.

С выпуском 0,20, который мы только что опубликовали, внутренние компоненты Node-RED теперь разделены на 6 отдельных модулей npm, вместе с оригинальным модулем node-red, который теперь выполняет задачу объединения этих модулей, чтобы пользователь не знал, что мы сделали.

Этот пост описывает, как мы это делали, и некоторые проблемы, с которыми мы столкнулись на этом пути. Если вы хотите увидеть это сами, код здесь.

Этот пост был представлен в LNUG в сентябре 2019 года.

https://youtu.be/_r4emDWlApA

### Один против многим хранилищ.

Когда я начал изучать, как структурировать код для поддержки этого подхода, мне пришлось решить, хранить ли весь код в одном репо или разбивать его на один репо на модуль.

Его разделение позволило бы понять, какой код принадлежит каждому модулю, и новым разработчикам было бы легче следовать структуре.

Но это также значительно увеличит административную нагрузку; управление несколькими репозиториями с несколькими списками выпусков и необходимостью тщательно координировать пул-запросы, когда новая функция охватывает несколько модулей.

Хранение кода в одном месте имело смысл. Тогда вопрос заключался в том, как это сделать на практике.

### механическая обработка

Я посмотрел вокруг на другие проекты, которые поддерживают несколько модулей в одном хранилище. Казалось, что существует разделение между теми, кто решил использовать установленные инструменты, такими как Lerna, и теми, кто разработал свое собственное решение.

Не желая без необходимости изобретать велосипед, я провел некоторое время, играя с Лерной.

Lerna - это инструмент, который оптимизирует рабочий процесс вокруг управления многопакетными репозиториями с помощью git и npm.

Проблема, которую я обнаружил, заключалась в том, что Лерна со временем выросла и многое делает. Это не обязательно плохо, но мне было трудно представить, как мы перейдем к его использованию. Я слишком увлекся отскоком между различными вариантами, которые он предоставляет, не останавливаясь на одном подходе.

Я также нашел этот пост от Нолана Лоусона о том, почему PouchDB отошел от Лерны, что дало некоторую практическую перспективу - хотя и давным-давно.

В конечном итоге я решил, что хочу понять структуру кода и последствия раскола, а не мгновенно передать это инструменту. Это не помешает нам принять Лерну в будущем - но мы сможем сделать это более информированно.

### Компоновка кода

Существующая структура кода уже была разделена между средой выполнения на основе node.js и браузером:

    ├── editor   // All editor src and resources
    ├── nodes    // The default core nodes
    ├── red      // The node.js runtime code
    └── test     // All test material

Основной целью переупаковки был весь код node.js в red каталоге.
Код был уже достаточно хорошо скомпонован, но он не был идеальным.

Он был полон заявлений о необходимости с относительными путями, которые делали предположения о том, где находятся конкретные файлы.

Основная задача заключалась в том, чтобы определить макет кода, который позволял бы обновлять операторы require до новой структуры модуля, при этом все еще просто работая при работе в среде разработки.

Именно здесь я наткнулся на подход, связанный с постом Нолана, - модель «Alle».

Сначала краткий обзор того, как узел загружает модуль.
Когда вы вызываете require с относительным путем, узел загружает этот файл напрямую.
Например, дана пара файлов в соседних каталогах:

    .
    ├── a
    │   └── index.js
    └── b
        └── index.js
        
Код в a/index.js может использовать следующий код для загрузки b/index.js:

    const moduleB = require("../b/index.js");

Теперь предположим, что a и b - правильно сформированные модули npm, поэтому они включают файл package.json. Вместо того, чтобы требовать использования относительного пути, мы хотим использовать имя модуля:

    const moduleB = require("b");

Когда вы передаете имя требуемого модуля, узел проверит текущий каталог на наличие каталога node_modules и найдет там модуль с таким именем. Если он не находит его, он проверяет родительский каталог на наличие node_modules и так далее, пока не достигнет корня файловой системы.
Мы могли бы воспользоваться этим при компоновке кода - добавив в структуру каталог node_modules:

    .
    └── node_modules
        ├── a
        │   └── index.js
        └── b
            └── index.js
            
Теперь, когда модуль a требует ("b"), узел будет искать структуру каталогов, находить каталог node_modules, а затем находить там модуль b.

Применение этого на практике привело к структуре:


    ├── packages
    │   └── node_modules
    │       ├── @node-red
    │       │   ├── editor-api
    │       │   ├── editor-client
    │       │   ├── nodes
    │       │   ├── registry
    │       │   ├── runtime
    │       │   └── util
    │       └── node-red
    └── test
        ├── editor
        ├── node_modules
        │   └── nr-test-utils
        ├── nodes
        └── unit
            ├── @node-red
            │   ├── editor-api
            │   ├── registry
            │   ├── runtime
            │   └── util
            └── node-red
                └── lib

Вы можете увидеть семь новых модулей в каталоге packages / node_modules. Теперь они могут требовать друг друга так же, как и при правильной установке с помощью npm.

Материал для испытаний также был реструктурирован в соответствии с макетом. Вы также можете заметить, что тот же прием использовался там, чтобы сделать модуль под названием nr-test-utils доступным для тестового материала.

Этот модуль предоставляет две функции: требовать и разрешать. Они могут использоваться тестовым материалом для запроса определенного файла из дерева исходных текстов без необходимости жесткого кодирования относительного пути из дерева тестового материала в исходное дерево.

### Заставить GitHub не игнорировать node_modules

Недостатком этого подхода является то, что многим IDE предписано игнорировать каталоги node_modules, поскольку они, как правило, не содержат кода, который разработчик должен редактировать.

  Добавление некоторых правил в .gitignore, чтобы не игнорировать эти каталоги, казалось, исправило это для моего предпочтительного редактора atom.
  
    node_modules
    !packages/node_modules
    !test/**/node_modules

Мы также обнаружили, что GitHub не будет генерировать diff при отображении изменений в любых файлах в этих каталогах, поэтому нам пришлось добавить файл .gitattributes, содержащий следующее:

    /packages/node_modules/** linguist-generated=false

Это работает в настольном представлении, но мобильное представление все еще подавляет различия - еще не найдено решение для этого.

### Управление зависимостями

Каждый из каталогов модуля имеет свой собственный package.json, в котором перечислены его зависимости как обычно. На верхнем уровне проекта также есть файл package.json, в котором перечислены все зависимости (включая зависимости разработки). Это означает, что нам не нужно запускать npm install в каждом каталоге модулей - фактически мы активно избегаем этого, поскольку в эти зависимости входят ссылки на другие наши модули, которые npm не сможет установить самостоятельно.


Это означает, что есть ограничения на управление зависимостями.


Любая новая зависимость требует добавления в двух местах; файл package.json верхнего уровня, устанавливаемый в среде разработки, и собственный файл package.json модуля, устанавливаемый при установке опубликованного модуля.


Как только у вас есть один и тот же фрагмент информации в двух местах, вы повышаете риск их рассинхронизации.


Метод «Alle», который я связал с предыдущими разговорами об автоматизации генерации отдельных файлов package.json - то, что мы не приняли.


Вместо этого, чтобы помочь справиться с этим, был добавлен новый скрипт, scripts / verify-package-dependencies.js, который проверяет, что каждая зависимость, указанная в отдельных файлах package.json модуля, также указана в файле package.json верхнего уровня и что версия спецификатор совпадает.


Набор тестов по умолчанию теперь включает эту проверку, поэтому сборка завершится неудачно, если будет найдено несоответствие. Сценарий также можно запустить с параметром --fix для автоматического обновления версий в файле модуля package.json, чтобы они соответствовали верхнему уровню.


Единственный сценарий, который не улавливается, - это когда новая зависимость добавляется в файл верхнего уровня, но не в отдельный модуль. Модульные тесты все равно пройдут, потому что модуль установлен на верхнем уровне - но опубликованный модуль будет отсутствовать. Мы должны быть осторожны в этом, пока мы не закроем пробел.


### Управление версиями

Другим важным конструктивным решением было то, как управлять номерами версий отдельных модулей. Например, если требуется исправление в одном модуле, мы опубликуем новую версию только этого модуля или повысим версию всех модулей.

Npm позволяет легко принять любой подход. Если бы мы хотели иметь возможность публиковать модули по отдельности, мы могли бы установить номера версий зависимостей на 0.20.x, чтобы они всегда получали самую последнюю версию, доступную в данном вспомогательном выпуске. Альтернативой было бы установить их на определенную версию, чтобы связать все модули на определенном уровне.

Проблема с несогласованностью версий заключается в том, что происходит, когда пользователь сталкивается с проблемой. Основной целью всего этого рефакторинга было скрыть внутренние детали раскола.

Если пользователь сталкивается с проблемой сегодня, он может сказать нам, какую версию Node-RED он установил с одним номером. Мы просто не смогли бы достичь нашей цели, если бы им пришлось предоставлять версии всех семи модулей, поэтому они точно знали бы, что они установили. Также было бы странно сказать, что им нужно обновить свою установку, чтобы получить исправление, но версия модуля красного узла не меняется.

Итак, сейчас мы собираемся синхронизировать все модули.

Чтобы помочь с этой задачей, был добавлен другой скрипт, scripts / set-package-version.js, который можно использовать для обновления всех отдельных файлов package.json с правильным номером версии.

### Создание релиза
У нас уже была задача сборки grunt release, которая взяла дерево исходников и создала модуль, который можно опубликовать на npm вместе с zip-файлом для загрузки в выпуск GitHub.

Эта задача была обновлена, чтобы теперь собрать 7 отдельных модулей, на этот раз упакованных в файлы tgz.

    .dist
    ├── modules
    │   ├── node-red-0.20.3.tgz
    │   ├── node-red-editor-api-0.20.3.tgz
    │   ├── node-red-editor-client-0.20.3.tgz
    │   ├── node-red-nodes-0.20.3.tgz
    │   ├── node-red-registry-0.20.3.tgz
    │   ├── node-red-runtime-0.20.3.tgz
    │   └── node-red-util-0.20.3.tgz
    └── node-red-0.20.3.zip
    
Эти tgz-файлы можно публиковать по одному в npm, что гарантирует, что модуль node-red выполняется последним. В настоящее время это ручное задание, и оно готово для автоматизации в будущем.

### Что дальше?

Подумав, опубликовав выпуск 0.20 и несколько последующих выпусков сопровождения, я очень доволен подходом, который мы выбрали. Помимо нескольких моментов автоматизации задач, которые мы могли бы добавить, я думаю, что мы создали структуру проекта, которая хорошо определена и с которой легко работать.

Основным успехом было то, что мы сделали это без единой проблемы от пользователя, связанной со структурой модуля или упаковкой. Пользователи не знают, что мы внесли эти изменения - если они не читают примечания к выпуску, где мы продолжаем говорить об этом.
